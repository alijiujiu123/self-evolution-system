#!/usr/bin/env node

/**
 * GitHub API Integration
 *
 * Creates issues and pull requests for optimization suggestions
 */

class GitHubAPI {
  constructor(options = {}) {
    this.token = options.token || process.env.EVOLUTION_GITHUB_TOKEN || '';
    this.repo = options.repo || process.env.EVOLUTION_REPO || 'alijiujiu123/openclaw';
    this.logger = options.logger;
    this.baseUrl = 'https://api.github.com';
  }

  /**
   * Create issue
   */
  async createIssue(issue) {
    if (!this.token) {
      this.logger?.warn('No GitHub token, skipping issue creation');
      return null;
    }

    try {
      const response = await fetch(`${this.baseUrl}/repos/${this.repo}/issues`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title: issue.title,
          body: issue.body,
          labels: issue.labels || ['optimization', 'auto-generated'],
        }),
      });

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();

      this.logger?.success('Issue created', {
        number: data.number,
        title: data.title,
        url: data.html_url,
      });

      return data;
    } catch (error) {
      this.logger?.error('Failed to create issue', {
        title: issue.title,
        error: error.message,
      });
      return null;
    }
  }

  /**
   * Create pull request
   */
  async createPR(pr) {
    if (!this.token) {
      this.logger?.warn('No GitHub token, skipping PR creation');
      return null;
    }

    try {
      const response = await fetch(`${this.baseUrl}/repos/${this.repo}/pulls`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title: pr.title,
          body: pr.body,
          head: pr.head,
          base: pr.base || 'main',
        }),
      });

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();

      this.logger?.success('Pull request created', {
        number: data.number,
        title: data.title,
        url: data.html_url,
      });

      return data;
    } catch (error) {
      this.logger?.error('Failed to create pull request', {
        title: pr.title,
        error: error.message,
      });
      return null;
    }
  }

  /**
   * Format optimization as issue
   */
  formatOptimizationIssue(optimization) {
    const title = `[${optimization.type.toUpperCase()}] ${optimization.description.slice(0, 60)}...`;

    const body = `## Optimization Suggestion

**Type:** ${optimization.type}
**Priority:** ${optimization.priority}
**Risk Level:** ${optimization.risk_level}
**Estimated Effort:** ${optimization.estimated_effort || 'Unknown'}

### Description
${optimization.description}

### Target File
\`${optimization.target_file || 'Multiple files'}\`

### Proposed Changes
\`\`\`diff
${optimization.diff_preview || 'No preview available'}
\`\`\`

### Benefits
${optimization.benefits ? optimization.benefits.map(b => `- ${b}`).join('\n') : 'Not specified'}

### Risks
${optimization.risks ? optimization.risks.map(r => `- ${r}`).join('\n') : 'Not specified'}

### Source
- Discovered via: Evolution System
- Reference: ${optimization.source_url || 'N/A'}

---
*This issue was automatically generated by the OpenClaw Evolution System*`;

    return {
      title,
      body,
      labels: [
        'optimization',
        'auto-generated',
        optimization.type,
        optimization.priority,
      ],
    };
  }

  /**
   * Create issue from optimization
   */
  async createOptimizationIssue(optimization) {
    const issue = this.formatOptimizationIssue(optimization);
    const result = await this.createIssue(issue);

    if (result) {
      return {
        issue_number: result.number,
        issue_url: result.html_url,
        type: 'issue',
      };
    }

    return null;
  }

  /**
   * Batch create issues
   */
  async createIssues(optimizations) {
    const results = [];

    for (const opt of optimizations) {
      // Only create issues for suggest action
      if (opt.action === 'suggest') {
        const result = await this.createOptimizationIssue(opt);
        if (result) {
          results.push({
            optimization_id: opt.id,
            ...result,
          });
        }

        // Rate limiting: wait 1s between requests
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    return results;
  }
}

module.exports = { GitHubAPI };

if (require.main === module) {
  const api = new GitHubAPI({ logger: console });

  const testOpt = {
    id: 1,
    type: 'refactor',
    priority: 'medium',
    risk_level: 'MEDIUM',
    description: 'Test optimization for code quality improvement',
    target_file: 'skills/evolution/lib/test.cjs',
    diff_preview: '- old code\n+ new code',
    benefits: ['Better readability', 'Improved performance'],
    risks: ['Potential breakage'],
    source_url: 'https://example.com',
    action: 'suggest',
  };

  api.createOptimizationIssue(testOpt).then(result => {
    console.log('Result:', result);
  }).catch(err => {
    console.error('Error:', err);
  });
}
